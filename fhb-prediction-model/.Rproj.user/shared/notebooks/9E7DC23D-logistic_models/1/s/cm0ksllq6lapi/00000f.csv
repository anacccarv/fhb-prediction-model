"0","# Risk-conditional severity per threshold"
"0","# Draws severity points either aligned with observations or from population"
"0","h_bw <- 0.06  # bandwidth for kernel weighting"
"0",""
"0","have_aligned_sev <- exists(""sev"") && length(sev) == length(y)"
"0",""
"0","if (have_aligned_sev) {"
"0","  # Severity aligned with each observation"
"0","  base_idx <- which(y == 1 & is.finite(p_hat) & is.finite(sev))"
"0","  p_ep  <- p_hat[base_idx]"
"0","  s_ep  <- sev[base_idx]  # fraction 0â€“1"
"0",""
"0","  draw_s_pts <- function(pt, S){"
"0","    w <- exp(- (p_ep - pt)^2 / (2 * h_bw^2))"
"0","    if (sum(w) == 0 || all(!is.finite(w))) w <- rep(1, length(p_ep))"
"0","    w <- pmax(w, 1e-9)"
"0","    s_frac <- sample(s_ep, size = S, replace = TRUE, prob = w)"
"0","    100 * s_frac  # Return in POINTS"
"0","  }"
"0",""
"0","} else {"
"0","  # Use population-level severity (years/locations with epidemic)"
"0","  stopifnot(exists(""sev_epid""))"
"0","  s_base <- sev_epid[is.finite(sev_epid)]"
"0","  s_base <- s_base[s_base >= 0 & s_base <= 1]"
"0",""
"0","  k_prec <- 25"
"0","  q <- seq(0, 1, by = 0.1)"
"0","  mu_q <- stats::quantile(s_base, probs = q, na.rm = TRUE)"
"0","  fit_mu <- stats::splinefun(x = q, y = mu_q, method = ""monoH.FC"")"
"0",""
"0","  draw_s_pts <- function(pt, S){"
"0","    r <- mean(p_hat[y==1] <= pt, na.rm = TRUE)"
"0","    m <- min(max(fit_mu(r), 0), 1)"
"0","    alpha <- max(m * k_prec, 1e-3)"
"0","    beta  <- max((1 - m) * k_prec, 1e-3)"
"0","    100 * rbeta(S, alpha, beta)"
"0","  }"
"0","}"
